---
title: 对象数据类型的常规操作
date: 2016-06-25 18:03:06
categories: JS
tags: 前端
---

## 对象数据类型的常规操作

### Boolean类型
> 只有两个值：true/false

如何把其他类型的数据转化为Boolean类型？
- Boolean
- !
- !!

```javascript
数字当中只有0和NaN是false

!'珠峰培训' ==>  !是先把其他数据转化为Boolean，然后取反
Boolean('') ==> false
Boolean(0) ==> false
Boolean(NaN) ==> false

```


**规律： 在Boolean类型中，只有以下五种的Boolean值为false：`0/NaN/空字符串/null/undefined，其余都为true`** 
---

###  null && undefined 都代表空

> - null  表示空对象指针
> - undefined   表示未定义

**null一般都是意料之中的没有，通俗理解一般都是认为手动的先赋值为null，后面的程序当中会再次被赋值；**
```javascript
var num = null;  // null是手动赋值,预示着后面我会把num的值进行修改
```

**undefined一般都不是认为手动控制的，大部分都是浏览器自主为空，后面可以赋值也可以不赋值；**
```javascript
var num;  // 此时变量的值，浏览器会分配的就是undefined
后面可以赋值也可以不赋值
```
---

### object数据对象类
> 普通对象
> 由大括号包裹起来
> 由0到多组键值对组成

`属性是用来描述当前对象特征的；属性名(键key)是当前具备的特征，属性值(值value)是对这个特征的描述,一组属性名+属性值成为键值对`
```
var obj = {
name: 'liuhuan',
age: 21
}
```

#### 对象的操作，对键值对的增删改查；

<h5>【获取】</h5>

语法：对象.属性/对象[属性]
obj.name
obj['name'] 一般来说，对象的属性名都是字符串格式的，属性值是不固定的，任何格式都可以

<h5>【增/改】</h5>

js对象中属性名是不允许重复的，是**唯一**的；
boj.name = 'eva';原有对象中存在name属性，此处修改属性值；
boj.sex = '女';原有对象中不存在sex属性，相当给当前对象新增属性；

<h5>【删除】</h5>

彻底删除：对象中不存在了

```javascript
delete obj['age'] //对象中不存在此属性
```

假删除：并没有移除此属性，只是让当前属性的值为空

```javascript
obj.sex = null;
```

`也可以赋值为undefined，但是因为浏览器默认找不到一个属性的时候报错是undefined，如果我们赋值也是undefined的话导致我们无法区分是否有这个属性；`

如果当前对象在获取属性值得时候，如果有这个属性名可以正常获取到值，哪怕是null，但是如果没有这个属性名，则获取的结果是undefined；

```javascript
//思考题：
var obj = {
name: 'liuhuan',
age: 21
}

obj['name']  // liuhuan
obj[name]  //undefined   此处的name 是一个变量
//'name' 是一个字符串值，代表的是本身；
//name 是一个变量，代表的是是本身存储的值；
```


关于对象的一点细节知识
一个对象中的属性名不仅仅是字符串格式的还有可能是数字格式的；

```javascript
var obj = {
  name: 'eva',
	0: 100
}
obj[0] // 100
obj['0'] // 100
```
当我们存储的属性名不是字符串也不是数字的时候，浏览器会把这个值转toString()换为字符串然后在进行存储

obj[{}]=300 =>  先把（{}）.toString()后的结果作为对象的属性名存储起来 obj['[object Object]'] = 300;
obj[{}]获取的时候也是先把对象转化为字符串然后在获取；

---

数组对象（对象由键值对组成的）

```javascript
var ary = [12,23,23];
```

通过观察结果，数组对象的属性名是数字，我们称之为索引；

---

### 浅析JS的运行机制
1. 当浏览器的内核/引擎渲染和解析JS的时候会提供一个供JS运行的环境，我们把这个环境称之为全局作用域(global scope);
2. 代码自上而下执行，在此之前还有一个变量提升阶段；
    1. 基本数据类型的值会存储在当前作用域下
##### `基本数据类型`是按照值在操作的，把原有的值复制一份放到新的空间，和原来的值没关系了，你是你的，我是我的；

```
var a = 12有三部操作：
  1.首先开辟一个存储空间将12放进去；
  2.在当前作用域中声明一个变量a；
  3.让声明的变量和存储的12进行关联； （把存储的12赋值给a，这一步复制操作叫做定义）
```

   2. 引用数据额类型的值不能直接存储到当前的作用域中（因为可能存储的内容过于复杂），我们需要先开辟一个新的空间（理解为仓库），把内容存储到这个空间中；

##### `引用数据类型`不是按值在操作的，他操作的是空间引用地址，把原来空间的地址赋值给新的变量，但是原来的空间没有被克隆，这样就会出现多个变量关联的是相同的空间，相互之间就会有影响了；
```
var obj1 = {n:100}
1.首先安开辟一个新的内存空间，把对象中的键值对一次存储起来（为了保证后来能够找到这个空间，从空间有个16进制的地址）；
2.声明一个变量
3.让变量和地址关联在一起，把空间地址赋值给变量
```

- 栈内存： 本身就是一个供js代码执行的环境，所有的基本类型的值都会直接在这里面开辟一个位置进行存储
- 堆内存： 用来存储引用类型中的信息值的，对象存储的是键值对，函数存储的是代码字符串

----

###  JS中的判断语句

只要有一个判断条件成立了，不管后面是否还有成立的条件，都不在判断执行了

> 不管if条件中写什么，最后总要将其计算出布尔类型的，来判断条件是否执行；
> 把其他值转换为Boolean值为false的只有五种：`0，NaN，null,undefined,控制符串；`

```javascript
if('3px'+3){
    //在JS中，加减乘除都是数学运算，除"+"以外，其余的运算符在计算的饿时候遇到了非数字类型，首先会转换为数字类型（Number），然后再进行计算，
    //+ 在JS中除了数学相加，还有字符串拼接的作用，如果运算中遇到了字符串，则为字符串拼接；

}
```
对象转为数字类型为NAN；字符也是；


### typeof（运算符）
在JS当中用来检测数据类型的方式之一，除此之外还有：
- instanceof   运算符
- constructor   方法
- Object.prototype.toString.call()    方法

```javascript
语法 type [value]

返回值： 使用typeof检测出来的结果是一个字符串，字符串中包含着对应的数据类型，例如：'Number'，

typeof null -> //'object'  因为null代表的是空对象指针，没有指向任何的内存空间

typeof 检测数组、正则、对象，最后返回的都是'object'，也就是基于这种方式无法细分对象；
```

2. 三元运算符
> 语法： 条件？成立:不成立;  相当于简单的if，else语句
- 如果三元运算符当中的某一部分不需要做任何处理，我们用null或者undefined或者void 0...占位即可，但是不可不写，不写报错；
```javascript
    var num =12;
    num>10?num++:num--;
    num>10?num++:null;
    //如果需要执行多条语句，则用括号包起来，语句之间用逗号隔开
    num>=10?(num++,num*=10):null;
```


3. switch case
> JS中的一种判断方式
> switch case应用于一个变量或者表达式在不同值情况下的不同操作，每种情况结束都要加break，结束整个判断；
- 特殊性：每一种case比较都是基于'==='绝对相等来完成的；

**'10' == 10  -->  相等比较，如果等号两边的值的类型不一样，先转换为同一种类型在进行比较，当前案例中就是把字符串'10'转化为数字10，然后再进行比较；**
**'10' === 10  -->  绝对比较，如果等号两边的值的类型不一样，则直接不相等，他要求类型的值都完全一样才相等（真实项目中为了保护代码的严谨性，我们更应该更多的使用绝对比较）**

`不加break，后面的条件是否成立都会被执行，利用此机制，我们可以完成一些特殊的处理，例如如果num=10和等于5都要做同一件事情，那么我们就不用加break了`
```javascript
    var num = 9;
    switch (num) {
        case 10:
        case 5:
            num--;
            break;
        defalut:
            num =0;
    }
```

