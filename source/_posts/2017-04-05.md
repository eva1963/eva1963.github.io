---
title: VUE的生命周期函数
date: 2017-10-05 12:53:52
categories: VUE
tags: vue,webpack,生命周期
---
#### vue的生命周期

vue实例从创建到销毁的过程，就是生命周期；也就是从开始创建，初始化数据，编译模板，挂载Dom，渲染更新卸载等一系列的过程，我们称之为vue的生命周期；

#### vue生命周期的作用

vue的生命周期中有很多时间钩子，让我们在控制整个vue实例过程中能形成更好的逻辑

#### vue生命周期的几个阶段

他可以分8个阶段：数据初始化之前/初始化结束，挂载前/挂载结束,更新前/更新结束，销毁前/销毁结束

**第一次加载会触发几个钩子,而且只执行一次：beforeCreate,created,beforeMount,mounted**

Dom渲染在mounted中就已经完成了

#### 周期使用的场景：

- beforeCreate:用来加loading事件；

- 加载实例是触发created：初始化完成时的时间都写在这里，可以在这里结束loading事件，异步请求也可以在这里调用；

- mounted：挂在元素，获取到Dom节点；

- updated：如果对数据统一处理，在这里写上相对应的函数；

- nextTick：更新数据后立即操作dom


#### 钩子函数
beforeCreate: 数据初始化之前

    在这个期间获取不到data里面的数据

created: 数据初始化完成，

    可以获取和操作data中的数据，一般用作Ajax操作获取数据

    只是把数据渲染出来了，页面还没有渲染

  el: '#app'等价于vm.\$mount('#app');   el的优先级比 \$mount高，只有没有el的时候才会看你当前mount；

#### template

只能有一个根元素包裹，他会替代掉el:'#app'，它提供用来包裹元素的标签,但是el必须保留，否则流程会错误
```
<template id="temp1">
 <div>
     <h1>11</h1>
 </div>
</template>
```
**beforeMount：**挂载之前，判断你的渲染模板正确与否

渲染出错，毁在这个阶段报错，下个阶段就渲染不出来了

**mount：**挂载完成，视图就渲染了
以上四个钩子函数只在初始时期执行一次，后续不会在执行



**beforeUpdate:** 数据改变，视图更新之前

**update:** 数据改变，视图更新完成,一般用watch代替了，不常用

**beforeDestroy:** 销毁之前，不会自动销毁，只能手动的去销毁

**destroyed：**销毁完成,切断了数据和视图之间的联系，不存在数据响应视图了

**vm.$destroy();**

不会销毁之前的内容，渲染好的 页面也保留下来，但是页面实例就不再起作用了

#### 获取元素：

给当前元素加上ref，就会添加大vm.$refs里面去，获取的时候只需要this.$refs.box既可；

- $refs是一个对象，里面存着所有加过ref属性的键值对
- 如果添加的ref属性名重复，后面的会覆盖前面的，因为对象的键值对不允许重复；
- 如果是循环出来的元素，那么此时li上添加的ref就是一个数组

    <template id="temp1">
        <div>
            <h1 ref="box">{{val}}</h1>
            <h1 ref="box">{{val}}</h1>
            <h1 ref="box1">{{val}}</h1>
            <h1 ref="box2">{{val}}</h1>
          <p ref="p" v-for="item in ary">{{item}}</p>	//此时this.$refs为 {box: h1, p: Array(3)}
        </div>
    </template>

    this.$refs的结果为 	{box: h1, box1: h1, box2: h1}

    <script>
            data: { ary: [1, 2, 3]},
            mounted(){
    		// 一般操作元素都在这里操作，为了保证真实性一般都在里面包一个this.$nextTick()，保证当前DOm是最新渲染的
                /* 因为数据修改再去渲染这个步骤是异步的，所以这两部分同步直接执行
                得到结果3，此时最新修改的ary还未渲染出来，等到updated更新完成之后，
                页面就已经根据最新的数据渲染完成了，此时获取到的refs的节点就是最新的了 */
      			//立即执行，数据以改变，然后去重新渲染的Dom的过程是异步的
                this.ary = [1,2,3,4,5,6];
                console.log(this.$refs.p.length);
    //          第二种办法：
               //等到Dom渲染完成之后在执行
                this.$nextTick(()=>{
                    console.log(this.$refs.p.length);
                })
            },
            updated(){
    			// 里面是异步的，渲染dom的过程
                console.log(this.$refs.p.length);
            }
    </script>



#### this.$nextTick()
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
- 是一个Promise实例



#### 定义组件Component:

做开发的时候一般使用情况： 定义组件的名字使用驼峰命名法，那么使用的时候组件名都是小写，加上“-”

- 组件是独立的，生命周期是独立的，数据也是独立的
- 组件也是data，但是必须是一个函数

局部组件：

- 定义组件
- 注册组件
- 使用组件

        let son = {
            template: '<div>我是你儿子</div>'
        };
        let component1 = {
            template: '<div><h1 @click="fn">{{val}}</h1><son></son></div>',
            data(){
                return {
                    val: 'lalla'
                }
            },
            methods: {
                fn() {
                    this.val = '哈哈哈';
                }
            },
            components: {
                son
            }
        
        };
        let vm = new Vue({
            el: '#app',
            data: {
                val: '123'
            },
            components: {
                component1,
                son
            }
        });

props用来接收父亲传给儿子数据

- props放着所有的属性，是一个对象，里面都是属性名的字符串
- 子组件用这个数据的时候用的是自己起的这个属性名
- required和default只能有一个，可以设置默认值
- 只能传给儿子，不能越级

     <template id="temp1">
        <div>
            <h1 @click="fn">{{val}}</h1>
            <son :i="index"></son>
        </div>
    </template>

    let son = {
            template: '<div>我是{{i}}你儿子</div>',
            props: {
                i: {
    //                type: [Number, String],
    //                required: true,
    //                default: '100000',

    //                自定义校验
                    validator(val) {
                        //return  true通过校验，false就是没通过校验
                        return val>100;
        
                    }
                },
    //            还可以这么写，校验的就是类型
                m: Number,
            }
        };

子传父，保持同步修改

两种方法，但是都用到**$emit**方法，详细看代码：

    //用.sync保持m和money的同步
    <child :m.sync="money"></child>
    //这是另外一个方法：用自定义事件通知的方式
    <child2 :m="money" @changemoney="change"></child2>
    
    <template id="child">
        <div>
            <h2>{{m}}</h2>
            <button @click="getMore">点我一下啊</button>
        </div>
    </template>
    
    <template id="child2">
        <div>
            <h2>{{m}}</h2>
            <button @click="getMore">点我</button>
        </div>
    </template>
    
      let vm = new Vue({
            el: '#app',
            data: {
                money: 1000
            },
            methods: {
              //第一个方法需要一个方法在子传父的时候，子通知父需要做的事情，所以有点麻烦，直接用sync更简单
              change(res) {
                  this.money = res;
              }
            },
            components: {
                child: {
                    template: '#child',
                    props: ['m'],
                    methods: {
                        getMore() {
                            this.$emit('update:m', 10000000);
                        }
                    }
                },
                child2: {
                    template: '#child2',
                    props: ['m'],
                    methods: {
                        getMore() {
                            this.$emit('changemoney',10000);
                        }
                    }
                }
            }
        })



