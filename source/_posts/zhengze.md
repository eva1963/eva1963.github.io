---
title: 正则
date: 2017-08-01 22:46:00
categories: JS
tags: 前端
---

> 用来处理字符串的规则，且只能用来处理字符串
> 处理包含两方面：
>  **`正则匹配`：验证当前字符串是否符合某个规则**
>  **`正则捕获`： 把一个正则符合规则的部分取到**


每一个正则都是由`元字符`和`修饰符`组成
创建正则的两种方式：字面量和构造函数
let reg1 = /^\d+s/g;

2. 正则两个斜杠之间包起来的都是元字符，后面出现的是修饰符
   **常用修饰符**
   `img`忽略大小写匹配，多行匹配，全局匹配，ES6加了u,y
   **常用元字符**
- 量词元字符
  `*` 0-多次
  `?` 0-1次
  `+`1-多次
  {n} 出现n次
  {n,} 出现n-多次
  {n,m}出现n-m次
- 特殊元字符
  `\d`0-9之间的任意数字
  `\D` 非0-9之间的任意数字
  `\w`匹配数字字母下划线任意一个
  `\W`匹配非数字字母下划线任意一个
  `\s`匹配任意一个空白字符(包括\t制表符)
  `\b`匹配边界符
  `\n`匹配一个换行符
  `\`转义字符，把一个普通字符转义为特殊的字符如\d代表数字，还可以具有特殊含义的转化为普通意思
  `.` 不仅仅是点，代表的是除换行符之外的任意字符
  `^`以某个元字符开头
  `$`以某个元字符结尾
  `x|y`x或y中的任意一个
  `[xyz]`xyz中的任意一个
  `[^xyz]`除了xyz以外的任意一个
  `[a-z]`或者0-9获取其中范围的任意一个字符，也可以取反前面加^就行，跟上面一样
  `()` 正则的分组
  `(?:)`当前分组只匹配不捕获
  `(?=)`正向预查
  `(?!)`负向预查

[普通元字符]
只要在正则当中出现的元字符除了特殊和有量词意义的以外，其余的都是普通元字符


- 分组的作用
    1. 改变默认的优先级
    2. 分组捕获
    3. 分组引用

`正则捕获`
**正则捕获使用的是正则中的EXEC方法**
 >    1.如果可以匹配获取的结果是一个数组，如果不能匹配获取的结果是NULL
 >       2.如果我们只在匹配的时候，想要获取大正则中部分信息，我们可以把这部分使用小括号包起来，形成一个分组，这样在捕获的时候，不仅可以把大正匹配的信息捕获到，而且还单独的把小分组匹配的部分信息也捕获到了(分组捕获) 3.有时候写小分组不是为了捕获信息，只是为了改变优先级或者进行分组引用，此时我们可以在分组的前面加上“?:”，代表只去匹配，但是不把这个分组内容捕获

#### 编写一个正则匹配身份证号码
```javascript
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(?:\d|X)$/;
console.log(reg.exec('130828199012040617'));
//=>EXEC实现的是正则捕获，获取的结果是一个数组，如果不匹配获取的结果是null，捕获的时候不仅把大正则匹配的信息捕获到，而且每一个小分组中的内容也捕获到了(分组捕获) : ["130828199012040617", "130828", "1990", "12", "04", "1", index: 0, input: "130828199012040617"]
```

正则引用

```javascript
let reg = /^.$/; //一个正则设置了^和$，那么代表的含义就是只能是XXX
let reg = /^[.]$/; //只能匹配.
let reg = /^[\d]$/; //只能匹配数字，此处括号里面的消磁了
let reg = /^[12]$/; //不是匹配12，而是匹配1和2任意一个即可
var reg = /^([a-z])([a-z])\2\1$/; //分组引用    'oppo'=>true*/
```

#### 正则捕获
> 把一个字符串当中和正则匹配的部分获取到

基于`EXEC`可以实现正则的捕获
	1. 当前字符和字符串不匹配，结果为**null**
	2. 如果匹配，不活的结果是一个数组   （0：大正则捕获到的内容，index：正则捕获的起始索引，input：原始操作的字符串）
	3. 执行一次EXEC只能捕获到第一个和正则匹配的内容，其余匹配的内容还没有捕获到，而且执行多次并没有什么用，是因为正则的捕获有懒惰性->只能捕获到第一个，剩余的都捕获不到

**reg.lastIndex  是正则在捕获当中下一次在字符串中查找的索引**
`手动修改lastIndex是无效的`
解决正则懒惰性，只需要加全局g，这个是唯一的方法

#####match
>在正则设置了g的情况下，基于match捕获到的内容只有大正则匹配的，小分组的内容没有单独抽取出来,不设置g的情况下和执行exec一样的

正则的贪婪性
每一次捕获的时候总是捕获到和正则匹配中最长的内容，例如'zhufeng2018zhu'捕获到的总是2018，而2，20，201也是符合规则的，而？可以解决他的贪婪性
如：reg = /\d+?/g;把问号放到量词元素的前面就不是出现0-1次的意思了，而是取消正则的贪婪性

`？`在正则中的作用:
1. 出现0-1次，作为量词元素
2. 取消正则的贪婪性
3. ?:只匹配不捕获
4. ?=正向预查
5. ?!负向预查

```javascript
let str = 'zhufeng2018';
let reg = /\d+/g;
console.log(reg.exec(str));         //2018
console.log(reg.exec('zhufeng2018prixun2019')); //2019
虽然捕获的不是同一个字符串，但是正则是同一个，上次正则处理的时候修改了lastIndex，也会对下一次匹配的新的字符串产生影响
```
```javascript
let str = 'zhufeng2018';
let reg = /(\d+)/g;

console.log(reg.test(str));
console.log(RegExp.$1);
```


### replace

1. reg和str匹配多少次，函数就被触发执行多少次，而且还传递了一些参数信息值
2. 每一次arg中存储的信息和执行EXEC捕获的信息相似（内置原理：每一次正则匹配的结果都把函数执行，然后基于EXEC把本次匹配的信息捕获到，然后把这个捕获到的信息传递给这个函数）
3. 每一次函数当中返回的是啥，就把大正则中匹配的内容替换成啥
```
str.replace(reg,function (...arg) {
    console.log(arg);
    return  'AA';
});
console.log(str);   //"zhufengAAzhufengAA"
```

